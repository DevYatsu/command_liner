import os
import sys
from command import Command
from command_liner import CommandLiner

# set the prefix to run your commands once the script is usable,
# that is after running generate-sh command
commands_prefix = "commandliner"
command_client = CommandLiner(commands_prefix)


def get_prefix():
    return commands_prefix


# DO NOT REMOVE THIS COMMAND
# run to create the shell script
generate_sh_command = Command("generate-sh", f"A command for generating a sh file to run the script. This file will make your script usable with the prefix chosen at the top: '{commands_prefix}'.").set_help(f"To run the command:\n\t* {commands_prefix} generate-sh").set_script(f'''

def generate_sh_script():    
    import os
    import stat
    import platform
    
    def is_process_ours():
        import os
        import platform
        
        symbolic_link_path = None
        if platform.system() == "Windows":
            symbolic_link_path = os.path.expanduser("~/AppData/Local/Programs/{commands_prefix}")
        else:
            symbolic_link_path = "/usr/local/bin/{commands_prefix}"
        
        target_path = os.readlink(symbolic_link_path)

        created_by_us = False
        # check if script linked to symbolic link has our script identifier
        with open(target_path, "r") as script_file:
            for line in script_file:
                if line.strip() == "### COMMAND_LINER_IDENTIFIER_DO_NOT_REMOVE_THIS_LINE ###":
                    created_by_us = True
                
        return created_by_us
    
    
    # set simlink dir
    symbolic_link_dir = None
    if platform.system() == "Windows":
        link_path = os.path.expanduser("~/AppData/Local/Programs/{commands_prefix}")
        if os.path.exists(link_path):
            if is_process_ours():
                return print("Shell script '{commands_prefix}' already generated")
            else:
                return print("Command prefix '{commands_prefix}' is already used by another process: change 'commands_prefix' and retry command 'generate-sh'")
        symbolic_link_dir = link_path
    else: 
        link_path = os.path.join("/usr/local/bin/", "{commands_prefix}")
        if os.path.exists(link_path):
            if is_process_ours():
                return print("Shell script '{commands_prefix}' already generated")
            else:            
                return print("Command prefix '{commands_prefix}' is already used by another process: change 'commands_prefix' and retry command 'generate-sh'")
        symbolic_link_path = link_path
    
    # Set the path for the shell script in the same directory
    shell_script_path = os.path.join('{os.getcwd()}', f"{commands_prefix}.sh")

    # Open the file in write mode
    with open(shell_script_path, "w") as script_file:
        # Write the script content
        script_file.write("#!/bin/bash\\n")
        script_file.write("### COMMAND_LINER_IDENTIFIER_DO_NOT_REMOVE_THIS_LINE ###\\n")
        script_file.write("# shell script generated by DevYatsu's command_liner on GitHub\\n\\n")
        
        script_file.write('python {os.path.abspath(__file__)} "$@"\\n')

    # Set the file permissions to make it executable
    os.chmod(shell_script_path, stat.S_IRWXU)  # Add execute permissions to the owner

    # create symlink
    os.symlink(shell_script_path, symbolic_link_path)

    print("Shell script generated, you can start using '{commands_prefix}' prefix to invoke the script")
generate_sh_script()
''')

# DO NOT REMOVE THIS COMMAND
# remove the shell script and magic link
# there is a security to only execute this action if symbolic link is created by us
destruct_sh_command = Command("destruct-sh", "A command for removing a sh file generated by the script. You cannot generate more than one file at a time, so you may need to remove the file before creating another one.").set_help(f"To run the command:\n\t* {commands_prefix} destruct-sh").set_script(f'''
def remove_sh_file():  
    import os 
    import platform
    
    symbolic_link_path = None
    if platform.system() == "Windows":
        symbolic_link_path = os.path.expanduser("~/AppData/Local/Programs/{commands_prefix}")
    else:
        symbolic_link_path = "/usr/local/bin/{commands_prefix}"
        
    target_path = os.readlink(symbolic_link_path)

    can_remove = False
    # check if script linked to symbolic link has our script identifier
    with open(target_path, "r") as script_file:
        for line in script_file:
            if line.strip() == "### COMMAND_LINER_IDENTIFIER_DO_NOT_REMOVE_THIS_LINE ###":
                can_remove = True
                
    if can_remove == False:
        print("Impossible to remove this file, was not created by command_liner script")
        return
    else:
        # remove link path 
        os.remove(symbolic_link_path)
        os.remove(target_path)
        print("Shell script removed.")
        
remove_sh_file()
''')

# example command, see more in ./example/commands.py
example_command = Command("example", "An example command.").set_help(
    f"To run the command:\n\t* example <param1> <param2>").add_params("param1", "param2").add_optional_parameter("param3").set_script('''
param1 = "+++"
param2 = "+++"
param3 = "+++"

print(param1)  
if param3 != "": # param3 is optional and set to "" if not add in command
    print(param3)                                            
print(param2)     
print(param1)     
print(param2) 
if param3 != "":
    print(param3)    
print(param1)     

''', "param1", "param2", "param3")

# put all commands here
commands = list([generate_sh_command, destruct_sh_command, example_command])

# run the script
command_client.append_commands(
    *commands).run_command(sys.argv)
